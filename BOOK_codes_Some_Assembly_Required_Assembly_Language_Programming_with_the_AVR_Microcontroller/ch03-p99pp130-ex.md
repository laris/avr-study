## EXERCISES
1. All of the following directives assemble a byte representing negative one. Which most clearly represents this intent? Why?
    - .db $FF
    - .db –1
    - .db 255
2. Which memory area is always considered to be uninitialized when the AVR processor is powered on? Which memories can be affected by the AVR programmer utility?
    - RAM, ROM
3. Write an assembly language directive that will generate a sequence of four bytes representing Fred’s name. Write another directive to generate the following sequence of four bytes: 70, 114, 101, 100. How do these two statements compare?
    - .db 'F', 'r', 'e', 'd'
    - .db  70, 114, 101, 100
4. What directive would cause the assembly of the 16-bit code for the number represented by 076234 (octal notation)?
    - 0x7C9C
5. Use a directive to define the symbol minimum as an alias for register 27.
    - .DEF SYMBOL = R27
6. Use a directive to create a constant symbol named LPP that is used to specify there will be 66 lines per page.
    - .EQU LPP = 66
7. Use a directive to define a symbol named isDefined as the number 0. This symbol may change value later in the program.
    - .SET isDefined = 0
8. Which directive would be best to create a data value in memory representing a 5-digit U.S. zipcode? Why? Write an assembly language statement to assemble your zipcode.
    - ZIPCODE: .byte 5
9. If you create an assembly language source file with some common assembly language routines used in your AVR programs, what directive would be used to incorporate those routines in another assembly language program you are writing?
    - .INCLUDE "src_file.asm"
10. What is the value of the PC (representing the code segment’s location counter) after the following statements are assembled?
    - .cseg
    - .org $FF    $FF
    - .db "abcd"  +2 $FF-$100
    - .dw 10      +2 $101
    - here: add r2, r2 $102
11. What is the value of the data segment location counter after the following statements are assembled?
    - .dseg
    - .org $60
    - a: .byte 7  $60+7 = $67
    - .byte 1     $68
    - .org $70    $70
    - .byte 1     $71
12. You are creating a table (two-dimensional array) in an assembly language program. The table needs half as many rows as columns. The number of columns should be set to 12.
    - table = 12 x columns, 6 x rows
    - a. Define two constant symbols (use directives) to represent the numRows and numCols in a table. Be sure that changing the 12 to another number will automatically adjust the number of rows.
      - .EQU numCols = 12
      - .EQU numRows = numCols/2 = 6
    - b. What happens if the number of columns is odd?
      - only keep integer, 3/2 = 1
    - c. Write a directive that sets the symbol numCells to the number of cells in a table with the above number of rows and columns.
      - .EQU nuCells = numCols*(numCols/2)
    - d. Assuming you used the / operator in part a., redo it using the >> operator (otherwise redo it using /). What happens now if the columns value is odd?
      - .EQU numRows = numCols >> 1
13. Use the conditional operator to write an expression that represents the ASCII code for "A” or "a,” depending on whether the symbol FLIP is even or odd, respectively.
    ```
    .SET FLIP = 11%2
    .SET FLIP = 12%2
         LDI R16,FLIP
         BREQ go_A
         RJMP go_a
    JP_A:
        ; print A
    JP_a:
        ; print a
    ```
14. What is the numeric value of each expression truncated to a single byte? You can answer in hex or unsigned decimal.
    - a. !2 = 0
    - b. ~0 = $FF
    - c. "\45" = '\' '4' '5' = '5'
    - d. 2 + 7/3 = 2+2 = 6
    - e. 0xFF << 0x04 = 0xFF << 4 = 0xFC
15. When the following instruction is assembled, will other machine instructions need to be generated by the assembler to evaluate the expression? Explain, listing the required instructions if applicable.
    ```
    ldi r16, a + 2/b
    ```
16. What constant will be assembled as a result of the following directives (give each answer in hexadecimal)?
    ```
    .eseg
    aa: .db 256       0x100
    .dw "A"           0x41
    bb: .dd 1 << 31   0x0
    .db bb-aa         0xbb - 0xaa
    ```
17. Lookup the CLC instruction. How many bits are needed to represent this instruction? How long is the opcode?
    - SREG_Carry 1 cycle, OPCODE = 0x9488, 1 x word, 1 cycle
    - BSET 1001-0100-0sss-1000 sss [0,7]
    - BCLR 1001-0100-1sss-1000
18. Lookup the CALL instruction. How many bits are required to represent this instruction? What is the opcode for the CALL instruction?
    - CALL  1001-010k-kkkk-111k
    - CALL  kkkk-kkkk-kkkk-kkkk
    - RCALL 1101-kkkk-kkkk-kkkk
19. Write an instruction to add register 3 to register 14 (the result is to be placed in R14). Write an instruction to subtract register 7 from register 9 and store the result in register 9. What complication would arise if the result needed to be stored in register 7 instead?
    ```
    ADD R14, R3
    SUB R9, R7
    ```
20. Design a loop using a conditional branch instruction that will repeat 255 times. What value will be used to initialize the loop counter? What initial value would be used to repeat the loop 256 times? Include two nop instuctions in the body of the loop. If the microcontroller is running at 1 MHz, how long will the code take to execute 256 iterations (answer in milliseconds)?
    ```
          CLR R0
          LDI R16,255 ; 0 for 256
    LOOP:
          INC R0
          NOP
          NOP
          DEC R16
          BRNE LOOP
    ```
    - 1MHz -> 1us per cycle
    - cycle: [ 2 x 1c (NOP) + 1 x 1c (DEC) + 1 x 2C (BRNE true) ] x 256 - 1 [ BRNE false]
21. The cpi and breq instructions are often used in sequence. That is, the processor performs a comparison and then the next instruction (breq) acts on the result of that comparison. Write a sequence of instructions that cause a branch to the label named found if register 20 contains the ASCII code for the letter "e".
    ```
    CPI   R20, 'e'
    BREQ  FOUND
    FOUND: HERE
    ```
22. The instructions that use labels for operands can also accept numbers (after all, labels represent numeric values). Write an instruction that copies the byte at address 0x00F0 of the data space into register 2.
    - .EQU ADR = 0x00F0
    - LDI ZH,HIGH(ADR)
    - LDI ZL, LOW(ADR)
    - LPM R2,ADR
23. Some might call the nop instruction an oxymoron. Why? Why would a processor have such an instruction (do a little research if necessary)?
    - do nothing?
    - blocking delay
24. Lookup the addresses of the I/O registers in the ATMEGA16A for the digital I/O port A. Write directives that correctly define the symbols PORTA, PINA, and DDRA.
    - .EQU PORTA = 0x28
    - .EQU DDRA  = 0x29
    - .EQU PINA  = 0x30
25. What statements are needed to configure the ATMEGA16A’s port B so all pins are outputs?
    - LDI DDRB, 0xFF ;output
    - LDI DDRB, 0    ;input
26. What statements are needed to configure the ATMEGA16A’s port D so the even numbered pins are inputs and the odd numbered pins are outputs?
    - 0b_0101_0101 = 0x55
    - 0b_1010_1010 = 0xAA
27. When using a port to control LEDs on the STK-500/XPLAIN, what bit value causes the LED to light up? Explain. When reading the state of a pushbutton, what bit value is read when the pushbutton is pressed? Explain.
    - both pullup, so logic 0 turn on LED and indicate push

## PROGRAMMING EXERCISES
1. Using a loop to introduce a carefully timed delay is not uncommon in AVR program development. A loop controlled by an 8-bit counter can only delay for relatively short times. If it is embedded inside another loop, longer delays are possible. Use a nested loop to obtain a delay of 1/2 second, assuming the processor is running at 1 MHz. Run the program in the simulator. You can set the simulated clock speed to 1 MHz (Debug menu, Simulator Options, Frequency) and then examine the Stop Watch in the processor toolbar (View menu, Toolbars, Processor). By setting a breakpoint on an instruction following the loop, you can see exactly how long the loop will take.
2. Write a program to flash the LEDs of the STK-500/XPLAIN. The display should cycle through three patterns, OOOooooo, ooOOOOoo, and oooooOOO (where O is on, o is off) and repeat forever. Use a delay loop of 1/3 second between each pattern change. The processor should be set to run at 2 MHz using the internal oscillator (this is the default for the XPLAIN board).
3. Rewrite the counter program (Program 2.2) to pause in the loop when any switch (pushbutton) is depressed. When all switches are released, the program resumes. Ignore the problem of switch bounce.
4. Rewrite the counter program (Program 2.2) to pause in the loop at the end of each iteration. The counter will only advance when any switch (pushbutton) changes state (a state change means a button value changes from 0 to 1 or from 1 to 0). Ignore the problem of switch bounce. You can keep the previous button state in a register and use the cp instruction to compare the values in two registers.
5. Write a program to count the number of times button number 1 is pressed; the count should be displayed on the LEDs in base two notation (on = 1, off = 0). Design the program so the release of button 1 causes the advance of the count by one. Pressing button 0 should clear the count (back to 0). Do not worry about switch bounce. What happens if the count exceeds 255?
6. Write a program to "walk a bit” from position 0 to position 7 of a byte. Display the current position of the bit by illuminating the LED in the same position. Each time button 0 is pressed, the bit should move one position to the left. When the bit "falls out” of the left end of the register, the program should halt (enter an infinite loop). Try to eliminate switch bounce if it is observed during testing.